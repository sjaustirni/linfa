var searchIndex = JSON.parse('{\
"linfa":{"doc":"<code>linfa</code> aims to provide a comprehensive toolkit to build …","i":[[0,"correlation","linfa","Correlation analysis for dataset features",null,null],[3,"PearsonCorrelation","linfa::correlation","Pearson Correlation Coefficients (or Bivariate …",null,null],[11,"from_dataset","","Calculate the Pearson Correlation Coefficients and …",0,[[["usize",15],["datasetbase",3],["option",4]]]],[11,"get_coeffs","","Return the Pearson\'s Correlation Coefficients",0,[[],["array1",6]]],[11,"get_p_values","","Return the p values supporting the null-hypothesis",0,[[],[["option",4],["array1",6]]]],[0,"dataset","linfa","Datasets",null,null],[0,"multi_target_model","linfa::dataset","Merge models with single target to multi-target models",null,null],[3,"MultiTargetModel","linfa::dataset::multi_target_model","",null,null],[11,"new","","Create a wrapper model from a list of single-target models",1,[[["box",3],["vec",3]]]],[8,"Float","linfa::dataset","Floating point numbers",null,null],[8,"Label","","Discrete labels",null,null],[3,"Pr","","Probability types",null,null],[12,"0","","",2,null],[11,"even","","",2,[[],["pr",3]]],[3,"DatasetBase","","DatasetBase",null,null],[12,"records","","",3,null],[12,"targets","","",3,null],[12,"weights","","",3,null],[3,"CountedTargets","","Targets with precomputed, counted labels",null,null],[6,"Dataset","","Dataset",null,null],[6,"DatasetView","","DatasetView",null,null],[6,"DatasetPr","","DatasetPr",null,null],[8,"Records","","Record trait",null,null],[16,"Elem","","",4,null],[10,"nsamples","","",4,[[],["usize",15]]],[10,"nfeatures","","",4,[[],["usize",15]]],[8,"AsTargets","","Return a reference to single or multiple target variables",null,null],[16,"Elem","","",5,null],[10,"as_multi_targets","","Returns a view on targets as two-dimensional array",5,[[],["arrayview2",6]]],[11,"try_single_target","","Convert to single target, fails for more than one target",5,[[],[["arrayview1",6],["result",6]]]],[8,"FromTargetArray","","Helper trait to construct counted labels",null,null],[16,"Owned","","",6,null],[16,"View","","",6,null],[10,"new_targets","","Create self object from new target array",6,[[["array2",6]]]],[10,"new_targets_view","","",6,[[["arrayview2",6]]]],[8,"AsTargetsMut","","",null,null],[16,"Elem","","",7,null],[10,"as_multi_targets_mut","","Returns a mutable view on targets as two-dimensional array",7,[[],["arrayviewmut2",6]]],[11,"try_single_target_mut","","Convert to single target, fails for more than one target",7,[[],[["arrayviewmut1",6],["result",6]]]],[8,"AsProbabilities","","Convert to probability matrix",null,null],[10,"as_multi_target_probabilities","","",8,[[],[["cowarray",6],["ix3",6],["pr",3]]]],[8,"Labels","","Get the labels in all targets",null,null],[16,"Elem","","",9,null],[10,"label_count","","",9,[[],[["vec",3],["hashmap",3]]]],[11,"label_set","","",9,[[],[["vec",3],["hashset",3]]]],[11,"labels","","",9,[[],["vec",3]]],[0,"error","linfa","Error types in Linfa",null,null],[6,"Result","linfa::error","",null,null],[4,"Error","","",null,null],[13,"Parameters","","",10,null],[13,"Priors","","",10,null],[13,"NotConverged","","",10,null],[13,"NdShape","","",10,null],[13,"NotEnoughSamples","","",10,null],[13,"MultipleTargets","","",10,null],[0,"prelude","linfa","Linfa prelude.",null,null],[0,"traits","","Provide traits for different classes of algorithms",null,null],[8,"Transformer","linfa::traits","Transformation algorithms",null,null],[10,"transform","","",11,[[]]],[8,"Fit","","Fittable algorithms",null,null],[16,"Object","","",12,null],[10,"fit","","",12,[[["datasetbase",3]]]],[8,"IncrementalFit","","Incremental algorithms",null,null],[16,"ObjectIn","","",13,null],[16,"ObjectOut","","",13,null],[10,"fit_with","","",13,[[["datasetbase",3]]]],[8,"Predict","","Predict with model",null,null],[10,"predict","","",14,[[]]],[8,"PredictRef","","Predict with model for reference of dataset",null,null],[10,"predict_ref","","",15,[[]]],[0,"metrics","linfa","Common metrics functions for classification and regression",null,null],[8,"BinaryClassification","linfa::metrics","Classification for binary-labels",null,null],[10,"roc","","",16,[[],[["receiveroperatingcharacteristic",3],["result",6]]]],[3,"ConfusionMatrix","","Confusion matrix for multi-label evaluation",null,null],[3,"ReceiverOperatingCharacteristic","","A Receiver Operating Characteristic for binary-label …",null,null],[8,"ToConfusionMatrix","","Classification for multi-label evaluation",null,null],[10,"confusion_matrix","","",17,[[],[["result",6],["confusionmatrix",3]]]],[8,"SilhouetteScore","","Evaluates the quality of a clustering using euclidean …",null,null],[10,"silhouette_score","","Evaluates the quality of a clustering.",18,[[],["result",6]]],[8,"MultiTargetRegression","","Regression metrices trait for multiple targets.",null,null],[11,"max_error","","Maximal error between two continuous variables",19,[[],[["result",6],["array1",6]]]],[11,"mean_absolute_error","","Mean error between two continuous variables",19,[[],[["result",6],["array1",6]]]],[11,"mean_squared_error","","Mean squared error between two continuous variables",19,[[],[["result",6],["array1",6]]]],[11,"mean_squared_log_error","","Mean squared log error between two continuous variables",19,[[],[["result",6],["array1",6]]]],[11,"median_absolute_error","","Median absolute error between two continuous variables",19,[[],[["result",6],["array1",6]]]],[11,"r2","","R squared coefficient, is the proportion of the variance …",19,[[],[["result",6],["array1",6]]]],[11,"explained_variance","","Same as R-Squared but with biased variance",19,[[],[["result",6],["array1",6]]]],[8,"SingleTargetRegression","","Regression metrices trait for single targets.",null,null],[11,"max_error","","Maximal error between two continuous variables",20,[[],["result",6]]],[11,"mean_absolute_error","","Mean error between two continuous variables",20,[[],["result",6]]],[11,"mean_squared_error","","Mean squared error between two continuous variables",20,[[],["result",6]]],[11,"mean_squared_log_error","","Mean squared log error between two continuous variables",20,[[],["result",6]]],[11,"median_absolute_error","","Median absolute error between two continuous variables",20,[[],["result",6]]],[11,"r2","","R squared coefficient, is the proportion of the variance …",20,[[],["result",6]]],[11,"explained_variance","","Same as R-Squared but with biased variance",20,[[],["result",6]]],[11,"from","linfa::correlation","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"predict","linfa::dataset::multi_target_model","",1,[[["arraybase",3],["dim",3]],[["arraybase",3],["datasetbase",3]]]],[11,"predict","","",1,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",1,[[["datasetbase",3]]]],[11,"predict","","",1,[[["arraybase",3]]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"from","linfa::dataset","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"init","","",2,[[],["usize",15]]],[11,"deref","","",2,[[["usize",15]]]],[11,"deref_mut","","",2,[[["usize",15]]]],[11,"drop","","",2,[[["usize",15]]]],[11,"vzip","","",2,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"init","","",3,[[],["usize",15]]],[11,"deref","","",3,[[["usize",15]]]],[11,"deref_mut","","",3,[[["usize",15]]]],[11,"drop","","",3,[[["usize",15]]]],[11,"vzip","","",3,[[]]],[11,"from","","",21,[[]]],[11,"into","","",21,[[]]],[11,"borrow","","",21,[[]]],[11,"borrow_mut","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"init","","",21,[[],["usize",15]]],[11,"deref","","",21,[[["usize",15]]]],[11,"deref_mut","","",21,[[["usize",15]]]],[11,"drop","","",21,[[["usize",15]]]],[11,"vzip","","",21,[[]]],[11,"from","linfa::error","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"to_string","","",10,[[],["string",3]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"init","","",10,[[],["usize",15]]],[11,"deref","","",10,[[["usize",15]]]],[11,"deref_mut","","",10,[[["usize",15]]]],[11,"drop","","",10,[[["usize",15]]]],[11,"vzip","","",10,[[]]],[11,"from","linfa::metrics","",22,[[]]],[11,"into","","",22,[[]]],[11,"borrow","","",22,[[]]],[11,"borrow_mut","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"try_into","","",22,[[],["result",4]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"init","","",22,[[],["usize",15]]],[11,"deref","","",22,[[["usize",15]]]],[11,"deref_mut","","",22,[[["usize",15]]]],[11,"drop","","",22,[[["usize",15]]]],[11,"vzip","","",22,[[]]],[11,"from","","",23,[[]]],[11,"into","","",23,[[]]],[11,"borrow","","",23,[[]]],[11,"borrow_mut","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"init","","",23,[[],["usize",15]]],[11,"deref","","",23,[[["usize",15]]]],[11,"deref_mut","","",23,[[["usize",15]]]],[11,"drop","","",23,[[["usize",15]]]],[11,"vzip","","",23,[[]]],[11,"nsamples","linfa::dataset","",3,[[],["usize",15]]],[11,"nfeatures","","",3,[[],["usize",15]]],[11,"as_multi_targets","","",3,[[],["arrayview2",6]]],[11,"as_multi_targets","","",21,[[],["arrayview2",6]]],[11,"new_targets","","",21,[[["array2",6]]]],[11,"new_targets_view","","",21,[[["arrayview2",6]]]],[11,"as_multi_targets_mut","","",3,[[],["arrayviewmut2",6]]],[11,"as_multi_targets_mut","","",21,[[],["arrayviewmut2",6]]],[11,"label_count","","",3,[[],[["vec",3],["hashmap",3]]]],[11,"label_count","","",3,[[],[["vec",3],["hashmap",3]]]],[11,"confusion_matrix","","",3,[[["datasetbase",3]],[["result",6],["confusionmatrix",3]]]],[11,"roc","","",3,[[["datasetbase",3]],[["receiveroperatingcharacteristic",3],["result",6]]]],[11,"silhouette_score","","",3,[[],["result",6]]],[11,"predict_ref","linfa::dataset::multi_target_model","",1,[[["arraybase",3]],["array2",6]]],[11,"from","linfa::dataset","",3,[[["arraybase",3]]]],[11,"from","","",3,[[]]],[11,"from","","",3,[[]]],[11,"from","linfa::error","",10,[[["shapeerror",3]]]],[11,"clone","linfa::dataset","",2,[[],["pr",3]]],[11,"clone","linfa::error","",10,[[],["error",4]]],[11,"eq","linfa::dataset","",2,[[],["bool",15]]],[11,"partial_cmp","","",2,[[["pr",3]],[["option",4],["ordering",4]]]],[11,"deref","","",2,[[],["f32",15]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","linfa::error","",10,[[["formatter",3]],["result",6]]],[11,"fmt","linfa::metrics","",22,[[["formatter",3]],["result",6]]],[11,"fmt","linfa::correlation","",0,[[["formatter",3]],["result",6]]],[11,"fmt","linfa::error","",10,[[["formatter",3]],["result",6]]],[11,"from_iter","linfa::dataset::multi_target_model","",1,[[["intoiterator",8]]]],[11,"source","linfa::error","",10,[[],[["option",4],["error",8]]]],[11,"pearson_correlation","linfa::dataset","Calculate the Pearson Correlation Coefficients from a …",3,[[],["pearsoncorrelation",3]]],[11,"pearson_correlation_with_p_value","","Calculate the Pearson Correlation Coefficients and …",3,[[["usize",15]],["pearsoncorrelation",3]]],[11,"new","","Create a new dataset from records and targets",3,[[["intotargets",8]],["datasetbase",3]]],[11,"targets","","Returns reference to targets",3,[[]]],[11,"weights","","Returns optionally weights",3,[[],["option",4]]],[11,"weight_for","","Return a single weight",3,[[["usize",15]],["f32",15]]],[11,"feature_names","","Returns feature names",3,[[],[["string",3],["vec",3]]]],[11,"records","","Return records of a dataset",3,[[]]],[11,"with_records","","Updates the records of a dataset",3,[[["records",8]],[["datasetbase",3],["records",8]]]],[11,"with_targets","","Updates the targets of a dataset",3,[[],["datasetbase",3]]],[11,"with_weights","","Updates the weights of a dataset",3,[[["array1",6],["f32",15]],["datasetbase",3]]],[11,"with_feature_names","","Updates the feature names of a dataset",3,[[["vec",3],["string",3],["into",8]],["datasetbase",3]]],[11,"map_targets","","Map targets with a function <code>f</code>",3,[[["fnmut",8]],[["array2",6],["datasetbase",3]]]],[11,"ntargets","","Return the number of targets in the dataset",3,[[],["usize",15]]],[11,"sample_iter","","Iterate over observations",3,[[],["iter",3]]],[11,"view","","Creates a view of a dataset",3,[[],[["datasetbase",3],["arrayview2",6]]]],[11,"feature_iter","","Iterate over features",3,[[],[["arraybase",3],["datasetiter",3]]]],[11,"target_iter","","Iterate over targets",3,[[],[["arraybase",3],["datasetiter",3]]]],[11,"split_with_ratio","","Split dataset into two disjoint chunks",3,[[["f32",15]]]],[11,"one_vs_all","","Produce N boolean targets from multi-class targets",3,[[],[["vec",3],["result",6]]]],[11,"label_frequencies_with_mask","","Calculates label frequencies from a dataset while masking …",3,[[],[["f32",15],["hashmap",3]]]],[11,"label_frequencies","","Calculates label frequencies from a dataset",3,[[],[["f32",15],["hashmap",3]]]],[11,"bootstrap","","Apply bootstrapping for samples and features",3,[[]]],[11,"bootstrap_samples","","Apply sample bootstrapping",3,[[["usize",15]]]],[11,"bootstrap_features","","Apply feature bootstrapping",3,[[["usize",15]]]],[11,"shuffle","","Produces a shuffled version of the current Dataset.",3,[[],[["datasetbase",3],["array2",6]]]],[11,"fold","","Performs K-folding on the dataset. The dataset is divided …",3,[[["usize",15]],["vec",3]]],[11,"sample_chunks","","",3,[[["usize",15]],["chunksiter",3]]],[11,"to_owned","","",3,[[],[["datasetbase",3],["array2",6]]]],[11,"iter_fold","","Allows to perform k-folding cross validation on fittable …",3,[[["usize",15],["fn",8]]]],[11,"split_with_ratio","","Split dataset into two disjoint chunks",3,[[["f32",15]]]],[11,"split_with_ratio","","Split dataset into two disjoint chunks",24,[[["f32",15]]]],[11,"new","","",21,[[]]],[11,"with_labels","","",3,[[],[["datasetbase",3],["array2",6],["countedtargets",3]]]],[11,"precision","linfa::metrics","Precision score, the number of correct classifications …",22,[[],["f32",15]]],[11,"recall","","Recall score, the number of correct classifications in …",22,[[],["f32",15]]],[11,"accuracy","","Accuracy score",22,[[],["f32",15]]],[11,"f_score","","F-beta-score",22,[[["f32",15]],["f32",15]]],[11,"f1_score","","F1-score, this is the F-beta-score for beta=1",22,[[],["f32",15]]],[11,"mcc","","Matthew Correlation Coefficients",22,[[],["f32",15]]],[11,"split_one_vs_all","","Split confusion matrix in N one-vs-all binary confusion …",22,[[],[["vec",3],["confusionmatrix",3]]]],[11,"split_one_vs_one","","Split confusion matrix in N*(N-1)/2 one-vs-one binary …",22,[[],[["vec",3],["confusionmatrix",3]]]],[11,"get_curve","","Returns the true-positive, false-positive curve",23,[[],["vec",3]]],[11,"get_thresholds","","Returns the threshold corresponding to each point",23,[[],[["vec",3],["f32",15]]]],[11,"area_under_curve","","Returns the Area-Under-Curve metric",23,[[],["f32",15]]],[11,"max_error","","Maximal error between two continuous variables",20,[[],["result",6]]],[11,"mean_absolute_error","","Mean error between two continuous variables",20,[[],["result",6]]],[11,"mean_squared_error","","Mean squared error between two continuous variables",20,[[],["result",6]]],[11,"mean_squared_log_error","","Mean squared log error between two continuous variables",20,[[],["result",6]]],[11,"median_absolute_error","","Median absolute error between two continuous variables",20,[[],["result",6]]],[11,"r2","","R squared coefficient, is the proportion of the variance …",20,[[],["result",6]]],[11,"explained_variance","","Same as R-Squared but with biased variance",20,[[],["result",6]]],[11,"max_error","","Maximal error between two continuous variables",19,[[],[["result",6],["array1",6]]]],[11,"mean_absolute_error","","Mean error between two continuous variables",19,[[],[["result",6],["array1",6]]]],[11,"mean_squared_error","","Mean squared error between two continuous variables",19,[[],[["result",6],["array1",6]]]],[11,"mean_squared_log_error","","Mean squared log error between two continuous variables",19,[[],[["result",6],["array1",6]]]],[11,"median_absolute_error","","Median absolute error between two continuous variables",19,[[],[["result",6],["array1",6]]]],[11,"r2","","R squared coefficient, is the proportion of the variance …",19,[[],[["result",6],["array1",6]]]],[11,"explained_variance","","Same as R-Squared but with biased variance",19,[[],[["result",6],["array1",6]]]]],"p":[[3,"PearsonCorrelation"],[3,"MultiTargetModel"],[3,"Pr"],[3,"DatasetBase"],[8,"Records"],[8,"AsTargets"],[8,"FromTargetArray"],[8,"AsTargetsMut"],[8,"AsProbabilities"],[8,"Labels"],[4,"Error"],[8,"Transformer"],[8,"Fit"],[8,"IncrementalFit"],[8,"Predict"],[8,"PredictRef"],[8,"BinaryClassification"],[8,"ToConfusionMatrix"],[8,"SilhouetteScore"],[8,"MultiTargetRegression"],[8,"SingleTargetRegression"],[3,"CountedTargets"],[3,"ConfusionMatrix"],[3,"ReceiverOperatingCharacteristic"],[6,"Dataset"]]},\
"linfa_bayes":{"doc":"Naive Bayes<code>linfa-bayes</code> aims to provide pure Rust …","i":[[4,"BayesError","linfa_bayes","An error when using a GaussianNB classifier",null,null],[13,"Stats","","Error when performing Max operation on data",0,null],[13,"BaseCrate","","",0,null],[6,"Result","","",null,null],[3,"GaussianNbParams","","Gaussian Naive Bayes (GaussianNB)",null,null],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"from","","",0,[[["minmaxerror",4]]]],[11,"from","","",0,[[["error",4]]]],[11,"default","","",1,[[]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"source","","",0,[[],[["option",4],["error",8]]]],[11,"fit","","Fit the model",1,[[["datasetbase",3]]]],[11,"fit_with","","Incrementally fit on a batch of samples",1,[[["datasetbase",3]]]],[11,"params","","Create new GaussianNB model with default values for its …",1,[[]]],[11,"var_smoothing","","Specifies the portion of the largest variance of all the …",1,[[["f64",15]]]]],"p":[[4,"BayesError"],[3,"GaussianNbParams"]]},\
"linfa_clustering":{"doc":"<code>linfa-clustering</code> aims to provide pure Rust implementations…","i":[[3,"AppxDbscan","linfa_clustering","DBSCAN (Density-based Spatial Clustering of Applications …",null,null],[3,"AppxDbscanLabeler","","Struct that labels a set of points according to the …",null,null],[3,"AppxDbscanHyperParams","","The set of hyperparameters that can be specified for the …",null,null],[3,"AppxDbscanHyperParamsBuilder","","Helper struct used to construct a set of hyperparameters …",null,null],[3,"Dbscan","","DBSCAN (Density-based Spatial Clustering of Applications …",null,null],[3,"DbscanHyperParams","","The set of hyperparameters that can be specified for the …",null,null],[3,"DbscanHyperParamsBuilder","","Helper struct used to construct a set of hyperparameters …",null,null],[3,"GaussianMixtureModel","","Gaussian Mixture Model (GMM) aims at clustering a dataset …",null,null],[4,"GmmError","","An error when modeling a GMM algorithm",null,null],[13,"InvalidValue","","When any of the hyperparameters are set the wrong value",0,null],[13,"LinalgError","","Errors encountered during linear algebra operations",0,null],[13,"EmptyCluster","","When a cluster has no more data point while fitting GMM",0,null],[13,"LowerBoundError","","When lower bound computation fails",0,null],[13,"NotConverged","","When fitting EM algorithm does not converge",0,null],[13,"KMeansError","","When initial KMeans fails",0,null],[4,"GmmCovarType","","A specifier for the type of the relation between …",null,null],[13,"Full","","each component has its own general covariance matrix",1,null],[4,"GmmInitMethod","","A specifier for the method used for the initialization of …",null,null],[13,"KMeans","","GMM fitting algorithm is initalized with the esult of the …",2,null],[13,"Random","","GMM fitting algorithm is initialized randomly.",2,null],[3,"GmmHyperParams","","The set of hyperparameters that can be specified for the …",null,null],[3,"KMeans","","K-means clustering aims to partition a set of unlabeled …",null,null],[5,"compute_inertia","","We compute inertia defined as the sum of the squared …",null,[[["arraybase",3],["arraybase",3],["arraybase",3]],["float",8]]],[4,"KMeansError","","An error when modeling a KMeans algorithm",null,null],[13,"InvalidValue","","When any of the hyperparameters are set the wrong value",3,null],[13,"InertiaError","","When inertia computation fails",3,null],[13,"NotConverged","","When fitting algorithm does not converge",3,null],[3,"KMeansHyperParams","","The set of hyperparameters that can be specified for the …",null,null],[3,"KMeansHyperParamsBuilder","","An helper struct used to construct a set of valid …",null,null],[4,"KMeansInit","","Specifies centroid initialization algorithm for KMeans.",null,null],[13,"Random","","Pick random points as centroids.",4,null],[13,"KMeansPlusPlus","","K-means++ algorithm. Using this over random …",4,null],[13,"KMeansPara","","K-means|| algorithm, a parallelized version of K-means++. …",4,null],[5,"generate_blobs","","Given an input matrix <code>blob_centroids</code>, with shape …",null,[[["usize",15],["arraybase",3]],[["f64",15],["array2",6]]]],[5,"generate_blob","","Generate <code>blob_size</code> data points (a \\\"blob\\\") around …",null,[[["usize",15],["arraybase",3]],[["f64",15],["array2",6]]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"init","","",5,[[],["usize",15]]],[11,"deref","","",5,[[["usize",15]]]],[11,"deref_mut","","",5,[[["usize",15]]]],[11,"drop","","",5,[[["usize",15]]]],[11,"vzip","","",5,[[]]],[11,"to_subset","","",5,[[],["option",4]]],[11,"is_in_subset","","",5,[[],["bool",15]]],[11,"to_subset_unchecked","","",5,[[]]],[11,"from_subset","","",5,[[]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"init","","",6,[[],["usize",15]]],[11,"deref","","",6,[[["usize",15]]]],[11,"deref_mut","","",6,[[["usize",15]]]],[11,"drop","","",6,[[["usize",15]]]],[11,"vzip","","",6,[[]]],[11,"to_subset","","",6,[[],["option",4]]],[11,"is_in_subset","","",6,[[],["bool",15]]],[11,"to_subset_unchecked","","",6,[[]]],[11,"from_subset","","",6,[[]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"init","","",7,[[],["usize",15]]],[11,"deref","","",7,[[["usize",15]]]],[11,"deref_mut","","",7,[[["usize",15]]]],[11,"drop","","",7,[[["usize",15]]]],[11,"vzip","","",7,[[]]],[11,"to_subset","","",7,[[],["option",4]]],[11,"is_in_subset","","",7,[[],["bool",15]]],[11,"to_subset_unchecked","","",7,[[]]],[11,"from_subset","","",7,[[]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"init","","",8,[[],["usize",15]]],[11,"deref","","",8,[[["usize",15]]]],[11,"deref_mut","","",8,[[["usize",15]]]],[11,"drop","","",8,[[["usize",15]]]],[11,"vzip","","",8,[[]]],[11,"to_subset","","",8,[[],["option",4]]],[11,"is_in_subset","","",8,[[],["bool",15]]],[11,"to_subset_unchecked","","",8,[[]]],[11,"from_subset","","",8,[[]]],[11,"from","","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"borrow_mut","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"init","","",9,[[],["usize",15]]],[11,"deref","","",9,[[["usize",15]]]],[11,"deref_mut","","",9,[[["usize",15]]]],[11,"drop","","",9,[[["usize",15]]]],[11,"vzip","","",9,[[]]],[11,"to_subset","","",9,[[],["option",4]]],[11,"is_in_subset","","",9,[[],["bool",15]]],[11,"to_subset_unchecked","","",9,[[]]],[11,"from_subset","","",9,[[]]],[11,"from","","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"borrow_mut","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"init","","",10,[[],["usize",15]]],[11,"deref","","",10,[[["usize",15]]]],[11,"deref_mut","","",10,[[["usize",15]]]],[11,"drop","","",10,[[["usize",15]]]],[11,"vzip","","",10,[[]]],[11,"to_subset","","",10,[[],["option",4]]],[11,"is_in_subset","","",10,[[],["bool",15]]],[11,"to_subset_unchecked","","",10,[[]]],[11,"from_subset","","",10,[[]]],[11,"from","","",11,[[]]],[11,"into","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"borrow_mut","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"init","","",11,[[],["usize",15]]],[11,"deref","","",11,[[["usize",15]]]],[11,"deref_mut","","",11,[[["usize",15]]]],[11,"drop","","",11,[[["usize",15]]]],[11,"vzip","","",11,[[]]],[11,"to_subset","","",11,[[],["option",4]]],[11,"is_in_subset","","",11,[[],["bool",15]]],[11,"to_subset_unchecked","","",11,[[]]],[11,"from_subset","","",11,[[]]],[11,"from","","",12,[[]]],[11,"into","","",12,[[]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"borrow_mut","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"predict","","",12,[[["arraybase",3],["dim",3]],[["arraybase",3],["datasetbase",3]]]],[11,"predict","","",12,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",12,[[["datasetbase",3]]]],[11,"predict","","",12,[[["arraybase",3]]]],[11,"init","","",12,[[],["usize",15]]],[11,"deref","","",12,[[["usize",15]]]],[11,"deref_mut","","",12,[[["usize",15]]]],[11,"drop","","",12,[[["usize",15]]]],[11,"vzip","","",12,[[]]],[11,"to_subset","","",12,[[],["option",4]]],[11,"is_in_subset","","",12,[[],["bool",15]]],[11,"to_subset_unchecked","","",12,[[]]],[11,"from_subset","","",12,[[]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"to_subset","","",0,[[],["option",4]]],[11,"is_in_subset","","",0,[[],["bool",15]]],[11,"to_subset_unchecked","","",0,[[]]],[11,"from_subset","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"to_subset","","",1,[[],["option",4]]],[11,"is_in_subset","","",1,[[],["bool",15]]],[11,"to_subset_unchecked","","",1,[[]]],[11,"from_subset","","",1,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"init","","",2,[[],["usize",15]]],[11,"deref","","",2,[[["usize",15]]]],[11,"deref_mut","","",2,[[["usize",15]]]],[11,"drop","","",2,[[["usize",15]]]],[11,"vzip","","",2,[[]]],[11,"to_subset","","",2,[[],["option",4]]],[11,"is_in_subset","","",2,[[],["bool",15]]],[11,"to_subset_unchecked","","",2,[[]]],[11,"from_subset","","",2,[[]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_owned","","",13,[[]]],[11,"clone_into","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"borrow_mut","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"init","","",13,[[],["usize",15]]],[11,"deref","","",13,[[["usize",15]]]],[11,"deref_mut","","",13,[[["usize",15]]]],[11,"drop","","",13,[[["usize",15]]]],[11,"vzip","","",13,[[]]],[11,"to_subset","","",13,[[],["option",4]]],[11,"is_in_subset","","",13,[[],["bool",15]]],[11,"to_subset_unchecked","","",13,[[]]],[11,"from_subset","","",13,[[]]],[11,"from","","",14,[[]]],[11,"into","","",14,[[]]],[11,"to_owned","","",14,[[]]],[11,"clone_into","","",14,[[]]],[11,"borrow","","",14,[[]]],[11,"borrow_mut","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"predict","","",14,[[["arraybase",3],["dim",3]],[["arraybase",3],["datasetbase",3]]]],[11,"predict","","",14,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",14,[[["datasetbase",3]]]],[11,"predict","","",14,[[["arraybase",3]]]],[11,"init","","",14,[[],["usize",15]]],[11,"deref","","",14,[[["usize",15]]]],[11,"deref_mut","","",14,[[["usize",15]]]],[11,"drop","","",14,[[["usize",15]]]],[11,"vzip","","",14,[[]]],[11,"to_subset","","",14,[[],["option",4]]],[11,"is_in_subset","","",14,[[],["bool",15]]],[11,"to_subset_unchecked","","",14,[[]]],[11,"from_subset","","",14,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_string","","",3,[[],["string",3]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"init","","",3,[[],["usize",15]]],[11,"deref","","",3,[[["usize",15]]]],[11,"deref_mut","","",3,[[["usize",15]]]],[11,"drop","","",3,[[["usize",15]]]],[11,"vzip","","",3,[[]]],[11,"to_subset","","",3,[[],["option",4]]],[11,"is_in_subset","","",3,[[],["bool",15]]],[11,"to_subset_unchecked","","",3,[[]]],[11,"from_subset","","",3,[[]]],[11,"from","","",15,[[]]],[11,"into","","",15,[[]]],[11,"to_owned","","",15,[[]]],[11,"clone_into","","",15,[[]]],[11,"borrow","","",15,[[]]],[11,"borrow_mut","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"init","","",15,[[],["usize",15]]],[11,"deref","","",15,[[["usize",15]]]],[11,"deref_mut","","",15,[[["usize",15]]]],[11,"drop","","",15,[[["usize",15]]]],[11,"vzip","","",15,[[]]],[11,"to_subset","","",15,[[],["option",4]]],[11,"is_in_subset","","",15,[[],["bool",15]]],[11,"to_subset_unchecked","","",15,[[]]],[11,"from_subset","","",15,[[]]],[11,"from","","",16,[[]]],[11,"into","","",16,[[]]],[11,"borrow","","",16,[[]]],[11,"borrow_mut","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"init","","",16,[[],["usize",15]]],[11,"deref","","",16,[[["usize",15]]]],[11,"deref_mut","","",16,[[["usize",15]]]],[11,"drop","","",16,[[["usize",15]]]],[11,"vzip","","",16,[[]]],[11,"to_subset","","",16,[[],["option",4]]],[11,"is_in_subset","","",16,[[],["bool",15]]],[11,"to_subset_unchecked","","",16,[[]]],[11,"from_subset","","",16,[[]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"init","","",4,[[],["usize",15]]],[11,"deref","","",4,[[["usize",15]]]],[11,"deref_mut","","",4,[[["usize",15]]]],[11,"drop","","",4,[[["usize",15]]]],[11,"vzip","","",4,[[]]],[11,"to_subset","","",4,[[],["option",4]]],[11,"is_in_subset","","",4,[[],["bool",15]]],[11,"to_subset_unchecked","","",4,[[]]],[11,"from_subset","","",4,[[]]],[11,"from","","",0,[[["linalgerror",4]],["gmmerror",4]]],[11,"from","","",0,[[["kmeanserror",4]],["gmmerror",4]]],[11,"clone","","",5,[[],["appxdbscan",3]]],[11,"clone","","",7,[[],["appxdbscanhyperparams",3]]],[11,"clone","","",9,[[],["dbscan",3]]],[11,"clone","","",10,[[],["dbscanhyperparams",3]]],[11,"clone","","",12,[[]]],[11,"clone","","",1,[[],["gmmcovartype",4]]],[11,"clone","","",2,[[],["gmminitmethod",4]]],[11,"clone","","",13,[[],["gmmhyperparams",3]]],[11,"clone","","",14,[[],["kmeans",3]]],[11,"clone","","",15,[[],["kmeanshyperparams",3]]],[11,"clone","","",4,[[],["kmeansinit",4]]],[11,"eq","","",5,[[["appxdbscan",3]],["bool",15]]],[11,"eq","","",7,[[["appxdbscanhyperparams",3]],["bool",15]]],[11,"ne","","",7,[[["appxdbscanhyperparams",3]],["bool",15]]],[11,"eq","","",9,[[["dbscan",3]],["bool",15]]],[11,"eq","","",10,[[["dbscanhyperparams",3]],["bool",15]]],[11,"ne","","",10,[[["dbscanhyperparams",3]],["bool",15]]],[11,"eq","","",12,[[["gaussianmixturemodel",3]],["bool",15]]],[11,"ne","","",12,[[["gaussianmixturemodel",3]],["bool",15]]],[11,"eq","","",1,[[["gmmcovartype",4]],["bool",15]]],[11,"eq","","",14,[[["kmeans",3]],["bool",15]]],[11,"ne","","",14,[[["kmeans",3]],["bool",15]]],[11,"eq","","",15,[[["kmeanshyperparams",3]],["bool",15]]],[11,"ne","","",15,[[["kmeanshyperparams",3]],["bool",15]]],[11,"eq","","",4,[[["kmeansinit",4]],["bool",15]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",10,[[["formatter",3]],["result",6]]],[11,"fmt","","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"predict_ref","","",12,[[["arraybase",3]],[["usize",15],["array1",6]]]],[11,"predict_ref","","Given an input matrix <code>observations</code>, with shape …",14,[[["arraybase",3]],[["usize",15],["array1",6]]]],[11,"transform","","",7,[[["arraybase",3]],[["option",4],["array1",6]]]],[11,"transform","","",7,[[["datasetbase",3],["arraybase",3]],[["arraybase",3],["datasetbase",3],["array1",6]]]],[11,"transform","","",8,[[["arraybase",3]],[["option",4],["array1",6]]]],[11,"transform","","",8,[[["datasetbase",3],["arraybase",3]],[["arraybase",3],["datasetbase",3],["array1",6]]]],[11,"transform","","",10,[[["arraybase",3]],[["option",4],["array1",6]]]],[11,"transform","","",10,[[["datasetbase",3],["arraybase",3]],[["arraybase",3],["datasetbase",3],["array1",6]]]],[11,"transform","","",11,[[["arraybase",3]],[["option",4],["array1",6]]]],[11,"transform","","",11,[[["datasetbase",3],["arraybase",3]],[["arraybase",3],["datasetbase",3],["array1",6]]]],[11,"fit","","",13,[[["datasetbase",3]]]],[11,"fit","","Given an input matrix <code>observations</code>, with shape …",15,[[["datasetbase",3]]]],[11,"fit","","",16,[[["datasetbase",3]]]],[11,"params","","",5,[[["usize",15]],[["appxdbscanhyperparamsbuilder",3],["float",8]]]],[11,"new","","Runs the Approximated DBSCAN algorithm on the provided …",6,[[["arrayview2",6],["appxdbscanhyperparams",3]],["appxdbscanlabeler",3]]],[11,"labels","","Gives the labels of every point provided in input to the …",6,[[],["array1",6]]],[11,"tolerance","","Distance between points for them to be considered …",8,[[]]],[11,"slack","","Approximation factor, allows the distance between two …",8,[[]]],[11,"build","","Return an instance of <code>AppxDbscanHyperParams</code> after having …",8,[[],["appxdbscanhyperparams",3]]],[11,"new","","Minimum number of neighboring points a point needs to …",7,[[["usize",15]],["appxdbscanhyperparamsbuilder",3]]],[11,"tolerance","","Two points are considered neighbors if the euclidean …",7,[[]]],[11,"minimum_points","","Minimum number of a points in a neighborhood around a …",7,[[],["usize",15]]],[11,"slack","","Approximation factor, allows the distance between two …",7,[[]]],[11,"appx_tolerance","","Maximum approximated radius, equal to …",7,[[]]],[11,"params","","",9,[[["usize",15]],[["float",8],["dbscanhyperparamsbuilder",3]]]],[11,"tolerance","","Distance between points for them to be considered …",11,[[]]],[11,"build","","Return an instance of <code>DbscanHyperParams</code> after having …",11,[[],["dbscanhyperparams",3]]],[11,"new","","Minimum number of neighboring points a point needs to …",10,[[["usize",15]],["dbscanhyperparamsbuilder",3]]],[11,"tolerance","","Two points are considered neighbors if the euclidean …",10,[[]]],[11,"minimum_points","","Minimum number of a points in a neighborhood around a …",10,[[],["usize",15]]],[11,"params","","",12,[[["usize",15]],[["gmmhyperparams",3],["isaac64rng",3]]]],[11,"weights","","",12,[[],["array1",6]]],[11,"means","","",12,[[],["array2",6]]],[11,"covariances","","",12,[[],["array3",6]]],[11,"precisions","","",12,[[],["array3",6]]],[11,"centroids","","",12,[[],["array2",6]]],[11,"new","","",13,[[["usize",15]],[["gmmhyperparams",3],["isaac64rng",3]]]],[11,"n_clusters","","",13,[[],["usize",15]]],[11,"covariance_type","","",13,[[],["gmmcovartype",4]]],[11,"tolerance","","",13,[[]]],[11,"reg_covariance","","",13,[[]]],[11,"n_runs","","",13,[[],["u64",15]]],[11,"max_n_iterations","","",13,[[],["u64",15]]],[11,"init_method","","",13,[[],["gmminitmethod",4]]],[11,"rng","","",13,[[]]],[11,"with_covariance_type","","Set the covariance type.",13,[[["gmmcovartype",4]]]],[11,"with_tolerance","","Set the convergence threshold. EM iterations will stop …",13,[[]]],[11,"with_reg_covariance","","Non-negative regularization added to the diagonal of …",13,[[]]],[11,"with_n_runs","","Set the number of initializations to perform. The best …",13,[[["u64",15]]]],[11,"with_max_n_iterations","","Set the number of EM iterations to perform.",13,[[["u64",15]]]],[11,"with_init_method","","Set the method used to initialize the weights, the means …",13,[[["gmminitmethod",4]]]],[11,"with_rng","","",13,[[["rng",8],["clone",8]],[["rng",8],["gmmhyperparams",3],["clone",8]]]],[11,"validate","","",13,[[],[["gmmerror",4],["result",4]]]],[11,"params","","",14,[[["usize",15]],[["kmeanshyperparamsbuilder",3],["isaac64rng",3]]]],[11,"params_with_rng","","",14,[[["usize",15],["rng",8],["clone",8]],[["rng",8],["kmeanshyperparamsbuilder",3],["clone",8]]]],[11,"centroids","","Return the set of centroids as a 2-dimensional matrix …",14,[[],["array2",6]]],[11,"iter_count","","Return the number of iterations taken by each run as an …",14,[[],["array1",6]]],[11,"cost","","Return the sum of distances between each training point …",14,[[]]],[11,"n_runs","","Set the value of <code>n_runs</code>.",16,[[["usize",15]]]],[11,"max_n_iterations","","Set the value of <code>max_n_iterations</code>.",16,[[["u64",15]]]],[11,"tolerance","","Set the value of <code>tolerance</code>.",16,[[]]],[11,"init_method","","Set the value of <code>init</code>.",16,[[["kmeansinit",4]]]],[11,"build","","Return an instance of <code>KMeansHyperParams</code> after having …",16,[[],["kmeanshyperparams",3]]],[11,"new","","",15,[[["usize",15]],[["kmeanshyperparamsbuilder",3],["isaac64rng",3]]]],[11,"new_with_rng","","<code>new</code> lets us configure our training algorithm parameters:",15,[[["usize",15]],["kmeanshyperparamsbuilder",3]]],[11,"n_runs","","The final results will be the best output of n_runs …",15,[[],["usize",15]]],[11,"tolerance","","The training is considered complete if the euclidean …",15,[[]]],[11,"max_n_iterations","","We exit the training loop when the number of training …",15,[[],["u64",15]]],[11,"n_clusters","","The number of clusters we will be looking for in the …",15,[[],["usize",15]]],[11,"init","","Cluster initialization strategy",15,[[],["kmeansinit",4]]],[11,"rng","","Returns a clone of the random generator",15,[[]]]],"p":[[4,"GmmError"],[4,"GmmCovarType"],[4,"GmmInitMethod"],[4,"KMeansError"],[4,"KMeansInit"],[3,"AppxDbscan"],[3,"AppxDbscanLabeler"],[3,"AppxDbscanHyperParams"],[3,"AppxDbscanHyperParamsBuilder"],[3,"Dbscan"],[3,"DbscanHyperParams"],[3,"DbscanHyperParamsBuilder"],[3,"GaussianMixtureModel"],[3,"GmmHyperParams"],[3,"KMeans"],[3,"KMeansHyperParams"],[3,"KMeansHyperParamsBuilder"]]},\
"linfa_datasets":{"doc":"Datasets<code>linfa-datasets</code> provides a collection of commonly …","i":[[5,"iris","linfa_datasets","Read in the iris-flower dataset from dataset path.",null,[[],[["f64",15],["dataset",6],["usize",15]]]],[5,"diabetes","","Read in the diabetes dataset from dataset path",null,[[],[["f64",15],["dataset",6]]]],[5,"winequality","","Read in the winequality dataset from dataset path",null,[[],[["f64",15],["dataset",6],["usize",15]]]],[5,"linnerud","","Read in the physical exercise dataset from dataset path.",null,[[],[["f64",15],["dataset",6]]]]],"p":[]},\
"linfa_elasticnet":{"doc":"Elastic NetThis library contains an elastic net …","i":[[4,"Error","linfa_elasticnet","",null,null],[13,"NotEnoughSamples","","The input has not enough samples",0,null],[13,"IllConditioned","","The input is singular",0,null],[13,"BaseCrate","","",0,null],[6,"Result","","",null,null],[3,"ElasticNetParams","","Linear regression with both L1 and L2 regularization",null,null],[12,"penalty","","",1,null],[12,"l1_ratio","","",1,null],[12,"with_intercept","","",1,null],[12,"max_iterations","","",1,null],[12,"tolerance","","",1,null],[3,"ElasticNet","","Elastic Net model",null,null],[11,"params","","Create a default elastic net model",2,[[],["elasticnetparams",3]]],[11,"ridge","","Create a ridge model",2,[[],["elasticnetparams",3]]],[11,"lasso","","Create a lasso model",2,[[],["elasticnetparams",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"predict","","",2,[[["dim",3],["arraybase",3]],[["arraybase",3],["datasetbase",3]]]],[11,"predict","","",2,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",2,[[["datasetbase",3]]]],[11,"predict","","",2,[[["arraybase",3]]]],[11,"init","","",2,[[],["usize",15]]],[11,"deref","","",2,[[["usize",15]]]],[11,"deref_mut","","",2,[[["usize",15]]]],[11,"drop","","",2,[[["usize",15]]]],[11,"vzip","","",2,[[]]],[11,"from","","",0,[[["error",4]]]],[11,"clone","","",0,[[],["error",4]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"source","","",0,[[],[["error",8],["option",4]]]],[11,"predict_ref","","Given an input matrix <code>X</code>, with shape …",2,[[["arraybase",3]],["array1",6]]],[11,"fit","","Fit an elastic net model given a feature matrix <code>x</code> and a …",1,[[["datasetbase",3]],[["elasticnet",3],["result",6]]]],[11,"parameters","","Get the fitted parameters",2,[[],["array1",6]]],[11,"intercept","","Get the fitted intercept, 0. if no intercept was fitted",2,[[]]],[11,"n_steps","","Get the number of steps taken in optimization algorithm",2,[[],["u32",15]]],[11,"duality_gap","","Get the duality gap at the end of the optimization …",2,[[]]],[11,"z_score","","Calculate the Z score",2,[[],[["array1",6],["result",6]]]],[11,"confidence_95th","","Calculate the confidence level",2,[[],[["result",6],["array1",6]]]],[11,"new","","Create default elastic net hyper parameters",1,[[],["elasticnetparams",3]]],[11,"penalty","","Set the overall parameter penalty parameter of the …",1,[[]]],[11,"l1_ratio","","Set l1_ratio parameter of the elastic net. Controls how …",1,[[]]],[11,"with_intercept","","Configure the elastic net model to fit an intercept. …",1,[[["bool",15]]]],[11,"tolerance","","Set the tolerance which is the minimum absolute change in …",1,[[]]],[11,"max_iterations","","Set the maximum number of iterations for the optimization …",1,[[["u32",15]]]],[11,"compute_intercept","","Compute the intercept as the mean of <code>y</code> and center <code>y</code> if an …",1,[[["arrayview1",6]]]],[11,"validate_params","","Validate the hyper parameters",1,[[],["result",6]]]],"p":[[4,"Error"],[3,"ElasticNetParams"],[3,"ElasticNet"]]},\
"linfa_hierarchical":{"doc":"Hierarchical Clustering<code>linfa-hierarchical</code> provides an …","i":[[4,"Method","linfa_hierarchical","A method for computing the dissimilarities between …",null,null],[13,"Single","","Assigns the minimum dissimilarity between all pairs of …",0,null],[13,"Complete","","Assigns the maximum dissimilarity between all pairs of …",0,null],[13,"Average","","Assigns the average dissimilarity between all pairs of …",0,null],[13,"Weighted","","Assigns the weighted dissimilarity between clusters.",0,null],[13,"Ward","","Assigns the Ward dissimilarity between clusters.",0,null],[13,"Centroid","","Assigns the centroid dissimilarity between clusters.",0,null],[13,"Median","","Assigns the median dissimilarity between clusters.",0,null],[3,"HierarchicalCluster","","Agglomerative hierarchical clustering",null,null],[11,"with_method","","Select a merging method",1,[[["method",4]],["hierarchicalcluster",3]]],[11,"num_clusters","","Stop merging when a certain number of clusters are reached",1,[[["usize",15]],["hierarchicalcluster",3]]],[11,"max_distance","","Stop merging when a certain distance is reached",1,[[],["hierarchicalcluster",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"fmt","","",0,[[["formatter",3]],[["error",3],["result",4]]]],[11,"clone","","",0,[[],["method",4]]],[11,"eq","","",0,[[["method",4]],["bool",15]]],[11,"from_str","","",0,[[["str",15]],[["result",4],["error",4],["method",4]]]],[11,"default","","",1,[[],["hierarchicalcluster",3]]],[11,"transform","","Perform hierarchical clustering of a similarity matrix",1,[[["kernel",6]],[["vec",3],["datasetbase",3],["kernel",6]]]],[11,"transform","","Perform hierarchical clustering of a similarity matrix",1,[[["kernel",6],["datasetbase",3]],[["vec",3],["datasetbase",3],["kernel",6]]]],[11,"into_method_chain","","Convert this linkage method into a nearest neighbor chain …",0,[[],[["option",4],["methodchain",4]]]]],"p":[[4,"Method"],[3,"HierarchicalCluster"]]},\
"linfa_ica":{"doc":"Independent Component Analysis (ICA)<code>linfa-ica</code> aims to …","i":[[0,"error","linfa_ica","",null,null],[6,"Result","linfa_ica::error","",null,null],[4,"FastIcaError","","An error when modeling FastICA algorithm",null,null],[13,"InvalidValue","","When any of the hyperparameters are set the wrong value",0,null],[13,"SvdDecomposition","","If we fail to compute any components of the SVD …",0,null],[13,"Linalg","","Errors encountered during linear algebra operations",0,null],[0,"fast_ica","linfa_ica","Fast algorithm for Independent Component Analysis (ICA)",null,null],[3,"FastIca","linfa_ica::fast_ica","Fast Independent Component Analysis (ICA)",null,null],[11,"new","","Create new FastICA algorithm with default values for its …",1,[[]]],[11,"ncomponents","","Set the number of components to use, if not set all are …",1,[[["usize",15]]]],[11,"gfunc","","G function used in the approximation to neg-entropy, …",1,[[["gfunc",4]]]],[11,"max_iter","","Set maximum number of iterations during fit",1,[[["usize",15]]]],[11,"tol","","Set tolerance on upate at each iteration",1,[[]]],[11,"random_state","","Set seed for random number generator for reproducible …",1,[[["usize",15]]]],[3,"FittedFastIca","","Fitted FastICA model for recovering the sources",null,null],[4,"GFunc","","Some standard non-linear functions",null,null],[13,"Logcosh","","",2,null],[13,"Exp","","",2,null],[13,"Cube","","",2,null],[11,"from","linfa_ica::error","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"from","linfa_ica::fast_ica","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"init","","",3,[[],["usize",15]]],[11,"deref","","",3,[[["usize",15]]]],[11,"deref_mut","","",3,[[["usize",15]]]],[11,"drop","","",3,[[["usize",15]]]],[11,"predict","","",3,[[["dim",3],["arraybase",3]],[["datasetbase",3],["arraybase",3]]]],[11,"predict","","",3,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",3,[[["datasetbase",3]]]],[11,"predict","","",3,[[["arraybase",3]]]],[11,"vzip","","",3,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"init","","",2,[[],["usize",15]]],[11,"deref","","",2,[[["usize",15]]]],[11,"deref_mut","","",2,[[["usize",15]]]],[11,"drop","","",2,[[["usize",15]]]],[11,"vzip","","",2,[[]]],[11,"from","linfa_ica::error","",0,[[["linalgerror",4]],["fasticaerror",4]]],[11,"default","linfa_ica::fast_ica","",1,[[]]],[11,"fmt","linfa_ica::error","",0,[[["formatter",3]],["result",6]]],[11,"fmt","linfa_ica::fast_ica","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","linfa_ica::error","",0,[[["formatter",3]],["result",6]]],[11,"predict_ref","linfa_ica::fast_ica","Recover the sources",3,[[["array2",6]],["array2",6]]],[11,"fit","","Fit the model",1,[[["datasetbase",3]],[["fittedfastica",3],["result",6]]]]],"p":[[4,"FastIcaError"],[3,"FastIca"],[4,"GFunc"],[3,"FittedFastIca"]]},\
"linfa_kernel":{"doc":"Kernel methodsKernel methods are a class of algorithms …","i":[[0,"inner","linfa_kernel","",null,null],[8,"Inner","linfa_kernel::inner","Specifies the methods an inner matrix of a kernel must be …",null,null],[16,"Elem","","",0,null],[10,"dot","","",0,[[["arrayview2",6]],["array2",6]]],[10,"sum","","",0,[[],["array1",6]]],[10,"size","","",0,[[],["usize",15]]],[10,"column","","",0,[[["usize",15]],["vec",3]]],[10,"to_upper_triangle","","",0,[[],["vec",3]]],[10,"is_dense","","",0,[[],["bool",15]]],[10,"diagonal","","",0,[[],["array1",6]]],[4,"KernelInner","","Allows a kernel to have either a dense or a sparse inner …",null,null],[13,"Dense","","",1,null],[13,"Sparse","","",1,null],[4,"KernelType","linfa_kernel","Kernel representation, can be either dense or sparse",null,null],[13,"Dense","","",2,null],[13,"Sparse","","A sparse kernel requires to define a number of neighbours …",2,null],[3,"KernelBase","","A generic kernel",null,null],[12,"inner","","",3,null],[12,"method","","The inner product that will be used by the kernel",3,null],[6,"Kernel","","Type definition of Kernel that owns its inner matrix",null,null],[6,"KernelView","","Type definition of Kernel that borrows its inner matrix",null,null],[11,"is_linear","","Whether the kernel is a linear kernel",3,[[],["bool",15]]],[11,"params","","Generates the default set of parameters for building a …",3,[[],["kernelparams",3]]],[11,"dot","","Performs the matrix product between the kernel matrix and …",3,[[["arrayview2",6]],["array2",6]]],[11,"sum","","Sums all elements in the same row of the kernel matrix",3,[[],["array1",6]]],[11,"size","","Gives the size of the side of the square kernel matrix",3,[[],["usize",15]]],[11,"column","","Getter for a column of the kernel matrix",3,[[["usize",15]],["vec",3]]],[11,"to_upper_triangle","","Getter for the data in the upper triangle of the kernel …",3,[[],["vec",3]]],[11,"diagonal","","Getter for the elements in the diagonal of the kernel …",3,[[],["array1",6]]],[11,"new","","",3,[[["kernelmethod",4],["arrayview2",6],["kerneltype",4]],["kernel",6]]],[11,"view","","Gives a KernelView which has a view on the original …",3,[[],["kernelview",6]]],[11,"new","","",4,[[["kernelmethod",4],["arrayview2",6],["kerneltype",4]],["kernel",6]]],[11,"view","","Gives a KernelView which has a view on the original …",4,[[],["kernelview",6]]],[11,"to_owned","","",3,[[],["kernel",6]]],[11,"to_owned","","",5,[[],["kernel",6]]],[4,"KernelMethod","","The inner product definition used by a kernel.",null,null],[13,"Gaussian","","Gaussian(eps): exp(-norm(x - x\')/eps)",6,null],[13,"Linear","","Euclidean inner product",6,null],[13,"Polynomial","","Polynomial(constant, degree):  …",6,null],[11,"distance","","",6,[[["arrayview1",6]]]],[11,"is_linear","","",6,[[],["bool",15]]],[3,"KernelParams","","Defines the set of parameters needed to build a kernel",null,null],[11,"method","","Setter for <code>method</code>. Can be chained with <code>kind</code> and <code>transform</code>.",7,[[["kernelmethod",4]],["kernelparams",3]]],[11,"kind","","Setter for <code>kind</code>. Can be chained with <code>method</code> and <code>transform</code>.",7,[[["kerneltype",4]],["kernelparams",3]]],[11,"from","linfa_kernel::inner","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"from","linfa_kernel","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"init","","",2,[[],["usize",15]]],[11,"deref","","",2,[[["usize",15]]]],[11,"deref_mut","","",2,[[["usize",15]]]],[11,"drop","","",2,[[["usize",15]]]],[11,"vzip","","",2,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"init","","",3,[[],["usize",15]]],[11,"deref","","",3,[[["usize",15]]]],[11,"deref_mut","","",3,[[["usize",15]]]],[11,"drop","","",3,[[["usize",15]]]],[11,"vzip","","",3,[[]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"init","","",6,[[],["usize",15]]],[11,"deref","","",6,[[["usize",15]]]],[11,"deref_mut","","",6,[[["usize",15]]]],[11,"drop","","",6,[[["usize",15]]]],[11,"vzip","","",6,[[]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"init","","",7,[[],["usize",15]]],[11,"deref","","",7,[[["usize",15]]]],[11,"deref_mut","","",7,[[["usize",15]]]],[11,"drop","","",7,[[["usize",15]]]],[11,"vzip","","",7,[[]]],[11,"clone","","",2,[[],["kerneltype",4]]],[11,"clone","","",6,[[],["kernelmethod",4]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"nsamples","","",3,[[],["usize",15]]],[11,"nfeatures","","",3,[[],["usize",15]]],[11,"transform","","Builds a kernel from a view of the input data.",7,[[["array2",6]],["kernel",6]]],[11,"transform","","Builds a kernel from a view of the input data.",7,[[["arrayview2",6]],["kernel",6]]],[11,"transform","","Builds a kernel from a view of the input data.",7,[[["arrayview2",6]],["kernel",6]]],[11,"transform","","Builds a new Dataset with the kernel as the records and …",7,[[["array2",6],["datasetbase",3]],[["datasetbase",3],["kernel",6]]]],[11,"transform","","Builds a new Dataset with the kernel as the records and …",7,[[["datasetbase",3]],[["datasetbase",3],["kernel",6]]]],[11,"transform","","Builds a new Dataset with the kernel as the records and …",7,[[["datasetbase",3]],[["datasetbase",3],["kernel",6]]]]],"p":[[8,"Inner"],[4,"KernelInner"],[4,"KernelType"],[3,"KernelBase"],[6,"Kernel"],[6,"KernelView"],[4,"KernelMethod"],[3,"KernelParams"]]},\
"linfa_linear":{"doc":"<code>linfa-linear</code> aims to provide pure Rust implementations of …","i":[[6,"Result","linfa_linear","",null,null],[4,"LinearError","","An error when modeling a Linear algorithm",null,null],[13,"Argmin","","Errors encountered when using argmin\'s solver",0,null],[13,"BaseCrate","","",0,null],[4,"Link","","Link functions used by GLM",null,null],[13,"Identity","","The identity link function <code>g(x)=x</code>",1,null],[13,"Log","","The log link function <code>g(x)=log(x)</code>",1,null],[13,"Logit","","The logit link function <code>g(x)=logit(x)</code>",1,null],[3,"TweedieRegressor","","Generalized Linear Model (GLM) with a Tweedie distribution",null,null],[3,"FittedTweedieRegressor","","Fitted Tweedie regressor model for scoring",null,null],[12,"coef","","Estimated coefficients for the linear predictor",2,null],[12,"intercept","","Intercept or bias added to the linear model",2,null],[8,"Float","","",null,null],[3,"LinearRegression","","An ordinary least squares linear regression model.",null,null],[3,"FittedLinearRegression","","A fitted linear regression model which can be used for …",null,null],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"vzip","","",0,[[]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"vzip","","",1,[[]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"vzip","","",3,[[]]],[11,"init","","",3,[[],["usize",15]]],[11,"deref","","",3,[[["usize",15]]]],[11,"deref_mut","","",3,[[["usize",15]]]],[11,"drop","","",3,[[["usize",15]]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"vzip","","",2,[[]]],[11,"init","","",2,[[],["usize",15]]],[11,"deref","","",2,[[["usize",15]]]],[11,"deref_mut","","",2,[[["usize",15]]]],[11,"drop","","",2,[[["usize",15]]]],[11,"predict","","",2,[[["arraybase",3],["dim",3]],[["datasetbase",3],["arraybase",3]]]],[11,"predict","","",2,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",2,[[["datasetbase",3]]]],[11,"predict","","",2,[[["arraybase",3]]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"vzip","","",4,[[]]],[11,"init","","",4,[[],["usize",15]]],[11,"deref","","",4,[[["usize",15]]]],[11,"deref_mut","","",4,[[["usize",15]]]],[11,"drop","","",4,[[["usize",15]]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"vzip","","",5,[[]]],[11,"init","","",5,[[],["usize",15]]],[11,"deref","","",5,[[["usize",15]]]],[11,"deref_mut","","",5,[[["usize",15]]]],[11,"drop","","",5,[[["usize",15]]]],[11,"predict","","",5,[[["arraybase",3],["dim",3]],[["datasetbase",3],["arraybase",3]]]],[11,"predict","","",5,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",5,[[["datasetbase",3]]]],[11,"predict","","",5,[[["arraybase",3]]]],[11,"from","","",0,[[["error",3]]]],[11,"from","","",0,[[["error",4]]]],[11,"clone","","",1,[[],["link",4]]],[11,"default","","",3,[[]]],[11,"default","","",4,[[]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"source","","",0,[[],[["option",4],["error",8]]]],[11,"deserialize","","",1,[[],["result",4]]],[11,"deserialize","","",3,[[],["result",4]]],[11,"deserialize","","",2,[[],["result",4]]],[11,"deserialize","","",4,[[],["result",4]]],[11,"deserialize","","",5,[[],["result",4]]],[11,"serialize","","",1,[[],["result",4]]],[11,"serialize","","",3,[[],["result",4]]],[11,"serialize","","",2,[[],["result",4]]],[11,"serialize","","",4,[[],["result",4]]],[11,"serialize","","",5,[[],["result",4]]],[11,"predict_ref","","Predict the target",2,[[["arraybase",3]],["array1",6]]],[11,"predict_ref","","Given an input matrix <code>X</code>, with shape …",5,[[["arraybase",3]],["array1",6]]],[11,"fit","","",3,[[["datasetbase",3]],[["result",6],["fittedtweedieregressor",3]]]],[11,"fit","","Fit a linear regression model given a feature matrix <code>X</code> …",4,[[["datasetbase",3]],[["string",3],["fittedlinearregression",3],["result",4]]]],[11,"link","","Compute the link function <code>g(ypred)</code>",1,[[["array1",6]],[["float",8],["array1",6]]]],[11,"link_derivative","","Computes the derivative of the link <code>g\'(ypred)</code>",1,[[["array1",6]],[["float",8],["array1",6]]]],[11,"inverse","","Computes the inverse link function <code>h(linear predictor)</code>",1,[[["array1",6]],[["float",8],["array1",6]]]],[11,"inverse_derviative","","Computes the derivative of the inverse link function …",1,[[["array1",6]],[["float",8],["array1",6]]]],[11,"new","","",3,[[]]],[11,"alpha","","Constant that multiplies with the penalty term and thus …",3,[[["f64",15]]]],[11,"fit_intercept","","Specifies whether a bias or intercept should be added to …",3,[[["bool",15]]]],[11,"power","","The power determines the underlying target distribution",3,[[["f64",15]]]],[11,"link","","The link function of the GLM, for mapping from linear …",3,[[["link",4]]]],[11,"max_iter","","Maximum number of iterations for the LBFGS solver",3,[[["usize",15]]]],[11,"tol","","Stopping criterion for the LBFGS solver",3,[[["f64",15]]]],[11,"new","","Create a default linear regression model.",4,[[],["linearregression",3]]],[11,"with_intercept","","Configure the linear regression model to fit an intercept.…",4,[[["bool",15]]]],[11,"with_intercept_and_normalize","","Configure the linear regression model to fit an intercept …",4,[[]]],[11,"params","","Get the fitted parameters",5,[[],["array1",6]]],[11,"intercept","","Get the fitted intercept, 0. if no intercept was fitted",5,[[]]]],"p":[[4,"LinearError"],[4,"Link"],[3,"FittedTweedieRegressor"],[3,"TweedieRegressor"],[3,"LinearRegression"],[3,"FittedLinearRegression"]]},\
"linfa_logistic":{"doc":"Logistic RegressionThe Big Picture<code>linfa-logistic</code> is a …","i":[[3,"LogisticRegression","linfa_logistic","A two-class logistic regression model.",null,null],[11,"new","","Creates a new LogisticRegression with default …",0,[[],["logisticregression",3]]],[11,"alpha","","Set the normalization parameter <code>alpha</code> used for L2 …",0,[[],["logisticregression",3]]],[11,"with_intercept","","Configure if an intercept should be fitted, defaults to …",0,[[["bool",15]],["logisticregression",3]]],[11,"max_iterations","","Configure the maximum number of iterations that the …",0,[[["u64",15]],["logisticregression",3]]],[11,"gradient_tolerance","","Configure the minimum change to the gradient to continue …",0,[[],["logisticregression",3]]],[11,"initial_params","","Configure the initial parameters from where the …",0,[[["array1",6]],["logisticregression",3]]],[3,"FittedLogisticRegression","","A fitted logistic regression which can make predictions",null,null],[11,"set_threshold","","Set the probability threshold for which the \'positive\' …",1,[[],["fittedlogisticregression",3]]],[11,"intercept","","",1,[[]]],[11,"params","","",1,[[],["array1",6]]],[11,"predict_probabilities","","Given a feature matrix, predict the probabilities that a …",1,[[["arraybase",3]],["array1",6]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"vzip","","",0,[[]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"vzip","","",1,[[]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"predict","","",1,[[["arraybase",3],["dim",3]],[["datasetbase",3],["arraybase",3]]]],[11,"predict","","",1,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",1,[[["datasetbase",3]]]],[11,"predict","","",1,[[["arraybase",3]]]],[11,"default","","",0,[[],["logisticregression",3]]],[11,"eq","","",1,[[["fittedlogisticregression",3]],["bool",15]]],[11,"ne","","",1,[[["fittedlogisticregression",3]],["bool",15]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"predict_ref","","Given a feature matrix, predict the classes learned when …",1,[[["arraybase",3]],["array1",6]]],[11,"fit","","Given a 2-dimensional feature matrix array <code>x</code> with shape …",0,[[["datasetbase",3]],[["result",4],["fittedlogisticregression",3],["string",3]]]]],"p":[[3,"LogisticRegression"],[3,"FittedLogisticRegression"]]},\
"linfa_pls":{"doc":"Partial Least Squares<code>linfa-pls</code> provides an implementation …","i":[[6,"Result","linfa_pls","",null,null],[4,"PlsError","","",null,null],[13,"NotEnoughSamplesError","","",0,null],[13,"BadComponentNumberError","","",0,null],[13,"PowerMethodNotConvergedError","","",0,null],[13,"LinalgError","","",0,null],[3,"PlsSvdParams","","",null,null],[3,"PlsSvd","","",null,null],[3,"PlsRegressionParams","","",null,null],[11,"max_iterations","","Set the maximum number of iterations of the power method …",1,[[["usize",15]]]],[11,"tolerance","","Set the tolerance used as convergence criteria in the …",1,[[]]],[11,"scale","","Set whether to scale the dataset",1,[[["bool",15]]]],[11,"algorithm","","Set the algorithm used to estimate the first singular …",1,[[["algorithm",4]]]],[3,"PlsRegression","","",null,null],[11,"params","","",2,[[["usize",15]],["plsregressionparams",3]]],[11,"weights","","Singular vectors of the cross-covariance matrices",2,[[]]],[11,"loadings","","Loadings of records and targets",2,[[]]],[11,"rotations","","Projection matrices used to transform records and targets",2,[[]]],[11,"coefficients","","The coefficients of the linear model such that Y is …",2,[[],["array2",6]]],[11,"inverse_transform","","Transform the given dataset in the projected space back …",2,[[["arraybase",3],["datasetbase",3]],[["datasetbase",3],["array2",6]]]],[3,"PlsCanonicalParams","","",null,null],[11,"max_iterations","","Set the maximum number of iterations of the power method …",3,[[["usize",15]]]],[11,"tolerance","","Set the tolerance used as convergence criteria in the …",3,[[]]],[11,"scale","","Set whether to scale the dataset",3,[[["bool",15]]]],[11,"algorithm","","Set the algorithm used to estimate the first singular …",3,[[["algorithm",4]]]],[3,"PlsCanonical","","",null,null],[11,"params","","",4,[[["usize",15]],["plscanonicalparams",3]]],[11,"weights","","Singular vectors of the cross-covariance matrices",4,[[]]],[11,"loadings","","Loadings of records and targets",4,[[]]],[11,"rotations","","Projection matrices used to transform records and targets",4,[[]]],[11,"coefficients","","The coefficients of the linear model such that Y is …",4,[[],["array2",6]]],[11,"inverse_transform","","Transform the given dataset in the projected space back …",4,[[["arraybase",3],["datasetbase",3]],[["datasetbase",3],["array2",6]]]],[3,"PlsCcaParams","","",null,null],[11,"max_iterations","","Set the maximum number of iterations of the power method …",5,[[["usize",15]]]],[11,"tolerance","","Set the tolerance used as convergence criteria in the …",5,[[]]],[11,"scale","","Set whether to scale the dataset",5,[[["bool",15]]]],[11,"algorithm","","Set the algorithm used to estimate the first singular …",5,[[["algorithm",4]]]],[3,"PlsCca","","",null,null],[11,"params","","",6,[[["usize",15]],["plsccaparams",3]]],[11,"weights","","Singular vectors of the cross-covariance matrices",6,[[]]],[11,"loadings","","Loadings of records and targets",6,[[]]],[11,"rotations","","Projection matrices used to transform records and targets",6,[[]]],[11,"coefficients","","The coefficients of the linear model such that Y is …",6,[[],["array2",6]]],[11,"inverse_transform","","Transform the given dataset in the projected space back …",6,[[["arraybase",3],["datasetbase",3]],[["datasetbase",3],["array2",6]]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"borrow_mut","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"init","","",7,[[],["usize",15]]],[11,"deref","","",7,[[["usize",15]]]],[11,"deref_mut","","",7,[[["usize",15]]]],[11,"drop","","",7,[[["usize",15]]]],[11,"vzip","","",7,[[]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"borrow_mut","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"init","","",8,[[],["usize",15]]],[11,"deref","","",8,[[["usize",15]]]],[11,"deref_mut","","",8,[[["usize",15]]]],[11,"drop","","",8,[[["usize",15]]]],[11,"vzip","","",8,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"init","","",2,[[],["usize",15]]],[11,"deref","","",2,[[["usize",15]]]],[11,"deref_mut","","",2,[[["usize",15]]]],[11,"drop","","",2,[[["usize",15]]]],[11,"predict","","",2,[[["arraybase",3],["dim",3]],[["arraybase",3],["datasetbase",3]]]],[11,"predict","","",2,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",2,[[["datasetbase",3]]]],[11,"predict","","",2,[[["arraybase",3]]]],[11,"vzip","","",2,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"init","","",3,[[],["usize",15]]],[11,"deref","","",3,[[["usize",15]]]],[11,"deref_mut","","",3,[[["usize",15]]]],[11,"drop","","",3,[[["usize",15]]]],[11,"vzip","","",3,[[]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"init","","",4,[[],["usize",15]]],[11,"deref","","",4,[[["usize",15]]]],[11,"deref_mut","","",4,[[["usize",15]]]],[11,"drop","","",4,[[["usize",15]]]],[11,"predict","","",4,[[["arraybase",3],["dim",3]],[["arraybase",3],["datasetbase",3]]]],[11,"predict","","",4,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",4,[[["datasetbase",3]]]],[11,"predict","","",4,[[["arraybase",3]]]],[11,"vzip","","",4,[[]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"init","","",5,[[],["usize",15]]],[11,"deref","","",5,[[["usize",15]]]],[11,"deref_mut","","",5,[[["usize",15]]]],[11,"drop","","",5,[[["usize",15]]]],[11,"vzip","","",5,[[]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"init","","",6,[[],["usize",15]]],[11,"deref","","",6,[[["usize",15]]]],[11,"deref_mut","","",6,[[["usize",15]]]],[11,"drop","","",6,[[["usize",15]]]],[11,"predict","","",6,[[["arraybase",3],["dim",3]],[["arraybase",3],["datasetbase",3]]]],[11,"predict","","",6,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",6,[[["datasetbase",3]]]],[11,"predict","","",6,[[["arraybase",3]]]],[11,"vzip","","",6,[[]]],[11,"from","","",0,[[["linalgerror",4]],["plserror",4]]],[11,"clone","","",7,[[],["plssvdparams",3]]],[11,"default","","",7,[[]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"predict_ref","","Given an input matrix <code>X</code>, with shape …",2,[[["arraybase",3]],["array2",6]]],[11,"predict_ref","","Given an input matrix <code>X</code>, with shape …",4,[[["arraybase",3]],["array2",6]]],[11,"predict_ref","","Given an input matrix <code>X</code>, with shape …",6,[[["arraybase",3]],["array2",6]]],[11,"transform","","",8,[[["arraybase",3],["datasetbase",3]],[["datasetbase",3],["array2",6]]]],[11,"transform","","Apply dimension reduction to the given dataset",2,[[["arraybase",3],["datasetbase",3]],[["datasetbase",3],["array2",6]]]],[11,"transform","","Apply dimension reduction to the given dataset",4,[[["arraybase",3],["datasetbase",3]],[["datasetbase",3],["array2",6]]]],[11,"transform","","Apply dimension reduction to the given dataset",6,[[["arraybase",3],["datasetbase",3]],[["datasetbase",3],["array2",6]]]],[11,"fit","","",7,[[["datasetbase",3]],[["result",6],["plssvd",3]]]],[11,"fit","","",1,[[["datasetbase",3]],[["result",6],["plsregression",3]]]],[11,"fit","","",3,[[["datasetbase",3]],[["result",6],["plscanonical",3]]]],[11,"fit","","",5,[[["datasetbase",3]],[["result",6],["plscca",3]]]],[11,"new","","",7,[[["usize",15]],["plssvdparams",3]]],[11,"scale","","",7,[[["bool",15]]]],[11,"params","","",8,[[["usize",15]],["plssvdparams",3]]],[11,"weights","","",8,[[]]]],"p":[[4,"PlsError"],[3,"PlsRegressionParams"],[3,"PlsRegression"],[3,"PlsCanonicalParams"],[3,"PlsCanonical"],[3,"PlsCcaParams"],[3,"PlsCca"],[3,"PlsSvdParams"],[3,"PlsSvd"]]},\
"linfa_reduction":{"doc":"Dimensionality reduction techniques","i":[[0,"diffusion_map","linfa_reduction","Diffusion Map",null,null],[3,"DiffusionMap","linfa_reduction::diffusion_map","Embedding of diffusion map technique",null,null],[3,"DiffusionMapParams","","Diffusion map hyperparameters",null,null],[12,"steps","","",0,null],[12,"embedding_size","","",0,null],[0,"pca","linfa_reduction","Principal Component Analysis",null,null],[3,"PcaParams","linfa_reduction::pca","Pincipal Component Analysis parameters",null,null],[11,"whiten","","Apply whitening to the embedding vector",1,[[["bool",15]]]],[3,"Pca","","Fitted Principal Component Analysis model",null,null],[11,"params","","Create default parameter set",2,[[["usize",15]],["pcaparams",3]]],[11,"explained_variance","","Return the amount of explained variance per element",2,[[],[["f64",15],["array1",6]]]],[11,"explained_variance_ratio","","Return the normalized amount of explained variance per …",2,[[],[["f64",15],["array1",6]]]],[11,"singular_values","","Return the singular values",2,[[],["array1",6]]],[0,"utils","linfa_reduction","",null,null],[5,"to_gaussian_similarity","linfa_reduction::utils","Computes a similarity matrix with gaussian kernel and …",null,[[["arraybase",3],["f64",15]],[["f64",15],["array2",6]]]],[5,"generate_swissroll","","Generates a three dimension swiss roll, centered at the …",null,[[["f64",15],["usize",15]],[["f64",15],["array2",6]]]],[5,"generate_convoluted_rings","","",null,[[["usize",15]],[["f64",15],["array2",6]]]],[5,"generate_convoluted_rings2d","","",null,[[["usize",15]],[["f64",15],["array2",6]]]],[5,"generate_blobs","","Given an input matrix <code>blob_centroids</code>, with shape …",null,[[["usize",15],["arraybase",3]],[["f64",15],["array2",6]]]],[5,"generate_blob","","Generate <code>blob_size</code> data points (a \\\"blob\\\") around …",null,[[["usize",15],["arraybase",3]],[["f64",15],["array2",6]]]],[3,"DiffusionMap","linfa_reduction","Embedding of diffusion map technique",null,null],[11,"from","linfa_reduction::diffusion_map","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"init","","",3,[[],["usize",15]]],[11,"deref","","",3,[[["usize",15]]]],[11,"deref_mut","","",3,[[["usize",15]]]],[11,"drop","","",3,[[["usize",15]]]],[11,"vzip","","",3,[[]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"from","linfa_reduction::pca","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"init","","",2,[[],["usize",15]]],[11,"deref","","",2,[[["usize",15]]]],[11,"deref_mut","","",2,[[["usize",15]]]],[11,"drop","","",2,[[["usize",15]]]],[11,"vzip","","",2,[[]]],[11,"predict","","",2,[[["dim",3],["arraybase",3]],[["datasetbase",3],["arraybase",3]]]],[11,"predict","","",2,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",2,[[["datasetbase",3]]]],[11,"predict","","",2,[[["arraybase",3]]]],[11,"clone","","",2,[[],["pca",3]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"predict_ref","","",2,[[["arraybase",3]],["array2",6]]],[11,"transform","linfa_reduction::diffusion_map","Project a kernel matrix to its embedding",0,[[["kernel",6]],[["diffusionmap",3],["result",6]]]],[11,"transform","linfa_reduction::pca","",2,[[["arraybase",3],["datasetbase",3]],[["array2",6],["datasetbase",3]]]],[11,"fit","","",1,[[["datasetbase",3]],[["f64",15],["pca",3]]]],[11,"params","linfa_reduction::diffusion_map","Creates the set of default parameters",3,[[["usize",15]],["diffusionmapparams",3]]],[11,"estimate_clusters","","Estimate the number of clusters in this embedding (very …",3,[[],["usize",15]]],[11,"eigvals","","Return the eigenvalue of the diffusion operator",3,[[],["array1",6]]],[11,"embedding","","Return the embedding",3,[[],["array2",6]]],[11,"steps","","Set the number of steps in the diffusion operator",0,[[["usize",15]]]],[11,"validate","","Validates the parameter",0,[[],["result",6]]]],"p":[[3,"DiffusionMapParams"],[3,"PcaParams"],[3,"Pca"],[3,"DiffusionMap"]]},\
"linfa_svm":{"doc":"Support Vector MachinesSupport Vector Machines are a …","i":[[0,"error","linfa_svm","",null,null],[6,"Result","linfa_svm::error","",null,null],[4,"SvmResult","","",null,null],[13,"BaseCrate","","",0,null],[0,"solver_smo","linfa_svm","",null,null],[3,"SolverParams","linfa_svm::solver_smo","Parameters of the solver routine",null,null],[12,"eps","","Stopping condition",1,null],[12,"shrinking","","Should we shrink, e.g. ignore bounded alphas",1,null],[4,"SeparatingHyperplane","","",null,null],[13,"Linear","","",2,null],[13,"WeightedCombination","","",2,null],[3,"SolverState","","Current state of the SMO solver",null,null],[11,"new","","Initialize a solver state",3,[[["solverparams",3],["arrayview2",6],["bool",15],["vec",3],["vec",3]],["solverstate",3]]],[11,"nactive","","Return number of active variables",3,[[],["usize",15]]],[11,"ntotal","","Return number of total variables",3,[[],["usize",15]]],[11,"target","","Return target as positive/negative indicator",3,[[["usize",15]]]],[11,"bound","","Return the k-th bound",3,[[["usize",15]]]],[11,"swap","","Swap two variables",3,[[["usize",15]]]],[11,"update","","",3,[[]]],[11,"max_violating_pair","","Return max and min gradients of free variables",3,[[]]],[11,"max_violating_pair_nu","","",3,[[]]],[11,"select_working_set","","Select optimal working set",3,[[]]],[11,"select_working_set_nu","","Select optimal working set",3,[[]]],[11,"should_shrunk","","",3,[[["usize",15]],["bool",15]]],[11,"should_shrunk_nu","","",3,[[["usize",15]],["bool",15]]],[11,"do_shrinking","","",3,[[]]],[11,"do_shrinking_nu","","",3,[[]]],[11,"calculate_rho","","",3,[[]]],[11,"calculate_rho_nu","","",3,[[]]],[11,"solve","","",3,[[],["svm",3]]],[3,"SvmParams","linfa_svm","SVM Hyperparameters",null,null],[11,"eps","","Set stopping condition",4,[[]]],[11,"shrinking","","Shrink active variable set",4,[[["bool",15]]]],[11,"with_kernel_params","","Set the kernel to use for training",4,[[["kernelparams",3]]]],[11,"gaussian_kernel","","Sets the model to use the Gaussian kernel. For this …",4,[[]]],[11,"polynomial_kernel","","Sets the model to use the Polynomial kernel. For this …",4,[[]]],[11,"linear_kernel","","Sets the model to use the Linear kernel. For this kernel …",4,[[]]],[11,"pos_neg_weights","","Set the C value for positive and negative samples.",4,[[]]],[11,"nu_weight","","Set the Nu value for classification",4,[[]]],[11,"c_eps","","Set the C value for regression",4,[[]]],[11,"nu_eps","","Set the Nu-Eps value for regression",4,[[]]],[4,"ExitReason","","Reason for stopping",null,null],[13,"ReachedThreshold","","",5,null],[13,"ReachedIterations","","",5,null],[3,"Svm","","Fitted Support Vector Machines model",null,null],[12,"alpha","","",6,null],[12,"rho","","",6,null],[11,"params","","Create hyper parameter set",6,[[],["svmparams",3]]],[11,"nsupport","","Returns the number of support vectors",6,[[],["usize",15]]],[11,"weighted_sum","","Sums the inner product of <code>sample</code> and every one of the …",6,[[["arraybase",3]]]],[11,"from","linfa_svm::error","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"from","linfa_svm::solver_smo","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"init","","",2,[[],["usize",15]]],[11,"deref","","",2,[[["usize",15]]]],[11,"deref_mut","","",2,[[["usize",15]]]],[11,"drop","","",2,[[["usize",15]]]],[11,"vzip","","",2,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"init","","",3,[[],["usize",15]]],[11,"deref","","",3,[[["usize",15]]]],[11,"deref_mut","","",3,[[["usize",15]]]],[11,"drop","","",3,[[["usize",15]]]],[11,"vzip","","",3,[[]]],[11,"from","linfa_svm","",4,[[]]],[11,"into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"init","","",4,[[],["usize",15]]],[11,"deref","","",4,[[["usize",15]]]],[11,"deref_mut","","",4,[[["usize",15]]]],[11,"drop","","",4,[[["usize",15]]]],[11,"vzip","","",4,[[]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"init","","",5,[[],["usize",15]]],[11,"deref","","",5,[[["usize",15]]]],[11,"deref_mut","","",5,[[["usize",15]]]],[11,"drop","","",5,[[["usize",15]]]],[11,"vzip","","",5,[[]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_string","","",6,[[],["string",3]]],[11,"borrow","","",6,[[]]],[11,"borrow_mut","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"predict","","",6,[[["arraybase",3],["dim",3]],[["datasetbase",3],["arraybase",3]]]],[11,"predict","","",6,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",6,[[["datasetbase",3]]]],[11,"predict","","",6,[[["arraybase",3]]]],[11,"init","","",6,[[],["usize",15]]],[11,"deref","","",6,[[["usize",15]]]],[11,"deref_mut","","",6,[[["usize",15]]]],[11,"drop","","",6,[[["usize",15]]]],[11,"vzip","","",6,[[]]],[11,"from","linfa_svm::error","",0,[[["error",4]]]],[11,"clone","linfa_svm::solver_smo","",1,[[],["solverparams",3]]],[11,"fmt","linfa_svm::error","",0,[[["formatter",3]],["result",6]]],[11,"fmt","linfa_svm","",5,[[["formatter",3]],["result",6]]],[11,"fmt","linfa_svm::error","",0,[[["formatter",3]],["result",6]]],[11,"fmt","linfa_svm","",6,[[["formatter",3]],["result",6]]],[11,"source","linfa_svm::error","",0,[[],[["option",4],["error",8]]]],[11,"predict","linfa_svm","",6,[[["array1",6]],["pr",3]]],[11,"predict","","",6,[[["arrayview1",6]],["pr",3]]],[11,"predict","","",6,[[["array1",6],["f32",15]],["f32",15]]],[11,"predict","","",6,[[["arrayview1",6],["f32",15]],["f32",15]]],[11,"predict","","",6,[[["f64",15],["array1",6]],["f64",15]]],[11,"predict","","",6,[[["f64",15],["arrayview1",6]],["f64",15]]],[11,"predict_ref","","",6,[[["arraybase",3]],[["array1",6],["pr",3]]]],[11,"predict_ref","","",6,[[["arraybase",3]],[["array1",6],["f32",15]]]],[11,"predict_ref","","",6,[[["arraybase",3]],[["f64",15],["array1",6]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]],[11,"fit","","",4,[[["datasetbase",3]]]]],"p":[[4,"SvmResult"],[3,"SolverParams"],[4,"SeparatingHyperplane"],[3,"SolverState"],[3,"SvmParams"],[4,"ExitReason"],[3,"Svm"]]},\
"linfa_trees":{"doc":"Decision tree learning<code>linfa-trees</code> aims to provide pure …","i":[[3,"TreeNode","linfa_trees","A node in the decision tree",null,null],[3,"DecisionTree","","A fitted decision tree model for classification.",null,null],[4,"SplitQuality","","The metric used to determine the feature by which a node …",null,null],[13,"Gini","","Measures the degree of probability of a randomly chosen …",0,null],[13,"Entropy","","Measures the entropy of a subtree, defined as the sum …",0,null],[3,"DecisionTreeParams","","The set of hyperparameters that can be specified for …",null,null],[12,"split_quality","","",1,null],[12,"max_depth","","",1,null],[12,"min_weight_split","","",1,null],[12,"min_weight_leaf","","",1,null],[12,"min_impurity_decrease","","",1,null],[12,"phantom","","",1,null],[3,"NodeIter","","Level-order (BFT) iterator of nodes in a decision tree",null,null],[3,"Tikz","","Struct to print a fitted decision tree in Tex using tikz …",null,null],[6,"Result","","",null,null],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"borrow_mut","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"init","","",2,[[],["usize",15]]],[11,"deref","","",2,[[["usize",15]]]],[11,"deref_mut","","",2,[[["usize",15]]]],[11,"drop","","",2,[[["usize",15]]]],[11,"vzip","","",2,[[]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"borrow_mut","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"init","","",3,[[],["usize",15]]],[11,"deref","","",3,[[["usize",15]]]],[11,"deref_mut","","",3,[[["usize",15]]]],[11,"drop","","",3,[[["usize",15]]]],[11,"predict","","",3,[[["arraybase",3],["dim",3]],[["arraybase",3],["datasetbase",3]]]],[11,"predict","","",3,[[["datasetbase",3]],["datasetbase",3]]],[11,"predict","","",3,[[["datasetbase",3]]]],[11,"predict","","",3,[[["arraybase",3]]]],[11,"vzip","","",3,[[]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"into_iter","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"borrow_mut","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"init","","",4,[[],["usize",15]]],[11,"deref","","",4,[[["usize",15]]]],[11,"deref_mut","","",4,[[["usize",15]]]],[11,"drop","","",4,[[["usize",15]]]],[11,"vzip","","",4,[[]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_string","","",5,[[],["string",3]]],[11,"borrow","","",5,[[]]],[11,"borrow_mut","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"init","","",5,[[],["usize",15]]],[11,"deref","","",5,[[["usize",15]]]],[11,"deref_mut","","",5,[[["usize",15]]]],[11,"drop","","",5,[[["usize",15]]]],[11,"vzip","","",5,[[]]],[11,"next","","",4,[[],["option",4]]],[11,"clone","","",2,[[],["treenode",3]]],[11,"clone","","",0,[[],["splitquality",4]]],[11,"clone","","",1,[[],["decisiontreeparams",3]]],[11,"eq","","",2,[[],["bool",15]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"hash","","",2,[[]]],[11,"predict_ref","","Make predictions for each row of a matrix of features <code>x</code>.",3,[[["arraybase",3]],["array1",6]]],[11,"fit","","Fit a decision tree using <code>hyperparamters</code> on the dataset …",1,[[["datasetbase",3]]]],[11,"is_leaf","","Returns true if the node has no children",2,[[],["bool",15]]],[11,"depth","","Returns the depth of the node in the decision tree",2,[[],["usize",15]]],[11,"prediction","","Returns <code>Some(prediction)</code> for leaf nodes and <code>None</code> for …",2,[[],["option",4]]],[11,"children","","Returns both children, first left then right",2,[[],[["vec",3],["option",4]]]],[11,"split","","Return the split (feature index, value) and its impurity …",2,[[]]],[11,"feature_name","","Returns the name of the feature used in the split if the …",2,[[],[["string",3],["option",4]]]],[11,"params","","Defaults are provided if the optional parameters are not …",3,[[],["decisiontreeparams",3]]],[11,"iter_nodes","","Create a node iterator in level-order (BFT)",3,[[],["nodeiter",3]]],[11,"features","","Return features_idx of this tree (BFT)",3,[[],[["usize",15],["vec",3]]]],[11,"mean_impurity_decrease","","Return the mean impurity decrease for each feature",3,[[],["vec",3]]],[11,"relative_impurity_decrease","","Return the relative impurity decrease for each feature",3,[[],["vec",3]]],[11,"feature_importance","","Return the feature importance, i.e. the relative impurity …",3,[[],["vec",3]]],[11,"root_node","","Return root node of the tree",3,[[],["treenode",3]]],[11,"max_depth","","Return max depth of the tree",3,[[],["usize",15]]],[11,"num_leaves","","Return the number of leaves in this tree",3,[[],["usize",15]]],[11,"export_to_tikz","","Generates a <code>Tikz</code> structure to print the fitted tree in …",3,[[],["tikz",3]]],[11,"split_quality","","Sets the metric used to decide the feature on which to …",1,[[["splitquality",4]]]],[11,"max_depth","","Sets the optional limit to the depth of the decision tree",1,[[["usize",15],["option",4]]]],[11,"min_weight_split","","Sets the minimum weight of samples required to split a …",1,[[["f32",15]]]],[11,"min_weight_leaf","","Sets the minimum weight of samples that a split has to …",1,[[["f32",15]]]],[11,"min_impurity_decrease","","Sets the minimum decrease in impurity that a split needs …",1,[[]]],[11,"validate","","Checks the correctness of the hyperparameters",1,[[],["result",6]]],[11,"new","","",4,[[["treenode",3],["vec",3]]]],[11,"new","","Creates a new Tikz structure for the decision tree with …",5,[[["decisiontree",3]]]],[11,"complete","","Whether a complete Tex document should be generated",5,[[["bool",15]]]],[11,"with_legend","","Add a legend to the generated tree",5,[[]]]],"p":[[4,"SplitQuality"],[3,"DecisionTreeParams"],[3,"TreeNode"],[3,"DecisionTree"],[3,"NodeIter"],[3,"Tikz"]]},\
"linfa_tsne":{"doc":"t-distributed stochastic neighbor embedding","i":[[6,"Result","linfa_tsne","",null,null],[4,"TSneError","","",null,null],[13,"NegativePerplexity","","",0,null],[13,"PerplexityTooLarge","","",0,null],[13,"NegativeApproximationThreshold","","",0,null],[13,"EmbeddingSizeTooLarge","","",0,null],[13,"PreliminaryIterationsTooLarge","","",0,null],[13,"InvalidShape","","",0,null],[13,"BaseCrate","","",0,null],[3,"TSne","","The t-SNE algorithm is a statistical method for …",null,null],[11,"embedding_size","","Create a t-SNE param set with given embedding size",1,[[["usize",15]],[["tsne",3],["smallrng",3]]]],[11,"embedding_size_with_rng","","Create a t-SNE param set with given embedding size and …",1,[[["usize",15]],["tsne",3]]],[11,"approx_threshold","","Set the approximation threshold of the Barnes Hut …",1,[[]]],[11,"perplexity","","Set the perplexity of the t-SNE algorithm",1,[[]]],[11,"max_iter","","Set the maximal number of iterations",1,[[["usize",15]]]],[11,"preliminary_iter","","Set the number of iterations after which the true P …",1,[[["usize",15]]]],[11,"validate","","Validates parameters",1,[[["usize",15]],["result",6]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"borrow_mut","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"init","","",0,[[],["usize",15]]],[11,"deref","","",0,[[["usize",15]]]],[11,"deref_mut","","",0,[[["usize",15]]]],[11,"drop","","",0,[[["usize",15]]]],[11,"vzip","","",0,[[]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"borrow_mut","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"init","","",1,[[],["usize",15]]],[11,"deref","","",1,[[["usize",15]]]],[11,"deref_mut","","",1,[[["usize",15]]]],[11,"drop","","",1,[[["usize",15]]]],[11,"vzip","","",1,[[]]],[11,"from","","",0,[[["shapeerror",3]]]],[11,"from","","",0,[[["error",4]]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"source","","",0,[[],[["option",4],["error",8]]]],[11,"transform","","",1,[[["array2",6]],[["array2",6],["result",6]]]],[11,"transform","","",1,[[["array2",6],["datasetbase",3]],[["datasetbase",3],["result",6]]]]],"p":[[4,"TSneError"],[3,"TSne"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);